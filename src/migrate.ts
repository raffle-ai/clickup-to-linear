import { countBy } from "es-toolkit";
import crypto from "crypto";
import {
  createClickUpClient,
  type TaskWithComments,
} from "./clickup/clickup-client";
import { linearClient } from "./linear/linear-client";
import type { IssueCreateInput } from "@linear/sdk/dist/_generated_documents";
import {
  getCycleByName,
  getLabelByName,
  getStateByName,
  getUserByEmail,
} from "./linear/lookup-data";
import { format } from "date-fns";
import pMap from "p-map";

const CURRENT_SPRINT_NUMBER = 43;

type Options = {
  dryRun: boolean;
  limit: number;
  id?: string; // limit export to a given task id
};

/**
 * Track ID created by Linear to assign parent iD when handling sub-tasks
 **/
const issueIdsByTaskId = new Map<string, string>();

export async function migrate(list: string, options: Options) {
  const client = createClickUpClient();

  const tasks = await client.getTasksAndCommentByList(list, options);
  showSummary(tasks);

  const issues = await processClickUpTasks(tasks, options);
  console.info(
    `List ${list} DONE! ${tasks.length} tasks processed${
      options.dryRun ? " (dry run)" : ""
    }`
  );
  showSummaryLinear(issues);
}

async function processClickUpTasks(
  tasks: TaskWithComments[],
  options: Options
) {
  const { dryRun } = options;

  const issues = await pMap(
    tasks,
    async (task, index) => {
      if (!dryRun) {
        console.log(
          `Processing ${index + 1}/${tasks.length}`,
          task.customId,
          task.title
        );
      }
      return await createIssueWithComments(task, dryRun);
    },
    { concurrency: 1 }
  );
  return issues;
}

async function createIssueWithComments(
  task: TaskWithComments,
  dryRun: boolean
) {
  const issue = convertClickUpTaskToLinearIssue(task);
  if (dryRun) {
    issueIdsByTaskId.set(task.id, "<random-id>"); // in the dryMode, we don't have the real ID generated by Linear
    return issue;
  }
  const result = await linearClient.createIssue(issue);

  const issueId = (await result.issue)?.id;
  if (!issueId)
    throw new Error(`No ID returned when creating issue ${task.customId}`);

  issueIdsByTaskId.set(task.id, issueId);

  for (const comment of task.comments) {
    await linearClient.createComment({
      issueId,
      body: `Comment by ${comment.email || "N/A"} \n` + comment.text,
      createdAt: comment.createdAt,
    });
  }

  // Comments have to be added before the issue is archived!
  if (shouldBeArchived(task)) {
    await linearClient.archiveIssue(issueId);
  }

  return issue;
}

function convertClickUpTaskToLinearIssue(
  task: TaskWithComments
): IssueCreateInput {
  const TEAM_ID = process.env.TEAM_ID;
  const PROJECT_ID = process.env.PROJECT_ID;

  if (!TEAM_ID) throw new Error("TEAM_ID is not set");
  if (!PROJECT_ID) throw new Error("PROJECT_ID is not set");

  const assignee = getUserByEmail(task.assignees[0]);
  const isCurrentSprint = task.listName === CURRENT_SPRINT_NUMBER.toString();
  const cycleId = isCurrentSprint
    ? getCycleByName(`Sprint ${CURRENT_SPRINT_NUMBER}`)?.id
    : undefined;

  const includesPrefix =
    !task.listName.toLowerCase().startsWith("backlog") && !isCurrentSprint;
  const prefix = includesPrefix ? getSprintName(task.listName!) + " " : "";
  const title = `${prefix}${task.customId} ${task.title}`;

  if (task.parentId && !issueIdsByTaskId.has(task.parentId)) {
    throw new Error(`Parent issue ID not found ${task.parentId}`);
  }
  const parentId = task.parentId
    ? issueIdsByTaskId.get(task.parentId)
    : undefined;

  const issueToCreate: IssueCreateInput = {
    teamId: TEAM_ID,
    projectId: PROJECT_ID,
    title,
    description:
      `Created by ${task.createdBy}: ${task.url}\n` + task.description,
    ...(assignee && { assigneeId: assignee.id }),
    stateId: getStatus(task)!.id,
    ...(task.dueDate && { dueDate: formatDate(task.dueDate) }),
    estimate: task.estimate,
    priority: getPriority(task.priority),
    subscriberIds: task.reviewers
      .map(getUserByEmail)
      .map((user) => user?.id)
      .filter(Boolean) as string[],
    labelIds: task.labels
      .map((label) => getLabelByName(label)?.id)
      .filter(Boolean) as string[],
    createdAt: task.createdAt,
    ...(parentId && { parentId }),
    cycleId, // we cannot create cycles in the past
  };
  // console.log("To create", issueToCreate);

  return issueToCreate;
}

function shouldBeArchived(task: TaskWithComments) {
  if (task.listName === CURRENT_SPRINT_NUMBER.toString()) return false;
  if (task.status === "done" || task.status === "rejected") return true;
  if (task.listName === "backlog") return false;
  if (task.isArchived) return true;
  return false;
}

function getSprintName(listName: string) {
  if (listName.toLowerCase().startsWith("backlog")) return "Backlog";
  return `Sprint ${listName}`;
}

function getStatus(task: TaskWithComments) {
  const { listName, status } = task;
  const notArchivedStatus: TaskWithComments["status"][] = [
    "to do",
    "in progress",
    "parked",
  ];
  if (listName === "backlog" && notArchivedStatus.includes(status)) {
    return getStateByName("Backlog");
  }

  switch (status) {
    case "done":
      return getStateByName("Done");
    case "to do":
      return getStateByName("ToDo");
    case "parked":
      return getStateByName("Parked");
    case "in review":
      return getStateByName("In Review");
    case "rejected":
      return getStateByName("Canceled");
    case "in progress":
      return getStateByName("In Progress");
    default:
      throw new Error(`Unknown status: ${status}`);
  }
}

function getPriority(input: TaskWithComments["priority"]) {
  return typeof input === "number" ? input + 1 : undefined; // "Urgent" is 1 in Linear, 0 in ClickUp
}

function formatDate(date?: Date) {
  return date ? format(date, "yyyy-MM-dd") : undefined;
}

function showSummary(tasks: TaskWithComments[]) {
  const statuses = countBy(tasks, (task) => task.status);
  const priorities = countBy(
    tasks,
    (task) => "Priority " + (task.priority ?? "not set")
  );
  const estimates = countBy(tasks, (task) => task.estimate ?? "not set");
  const labels = countBy(tasks, (task) => task.labels[0] || "not set");
  const commentsCounts = countBy(
    tasks,
    (task) => `${task.comments.length} comments`
  );
  const reviewers = countBy(tasks, (task) => task.reviewers[0] || "not set");
  console.log(
    statuses,
    priorities,
    estimates,
    labels,
    commentsCounts,
    reviewers
  );
}

function showSummaryLinear(issues: IssueCreateInput[]) {
  const statuses = countBy(issues, (issue) => issue?.stateId || "-");

  console.log("Results", statuses);
}
