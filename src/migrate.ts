import { countBy } from "es-toolkit";
import {
  createClickUpClient,
  type TaskWithComments,
} from "./clickup/clickup-client";
import { linearClient } from "./linear/linear-client";
import type { IssueCreateInput } from "@linear/sdk/dist/_generated_documents";
import {
  getCycleByName,
  getLabelByName,
  getStateByName,
  getUserByEmail,
} from "./linear/lookup-data";
import { format } from "date-fns";
import pMap from "p-map";

const CURRENT_SPRINT_NUMBER = process.env.CURRENT_SPRINT_NUMBER;

type Options = {
  dryRun: boolean;
  limit: number;
  page: number;
  id?: string; // limit export to a given task id
};

/**
 * Track ID created by Linear to assign parent iD when handling sub-tasks
 **/
const issueIdsByTaskId = new Map<string, string>();

export async function migrate(list: string, options: Options) {
  const client = createClickUpClient();

  const tasks = await client.getTasksAndCommentByList(list, options);
  showSummary(tasks);

  await processClickUpTasks(tasks, options);
  console.info(
    `List ${list} DONE! ${tasks.length} tasks processed${
      options.dryRun ? " (dry run)" : ""
    }`
  );
}

async function processClickUpTasks(
  allTasks: TaskWithComments[],
  options: Options
) {
  const { dryRun, id } = options;
  let index = 0;

  const topLevelTasks = allTasks.filter((task) => !task.parentId);
  const tasksToProcess = options.id
    ? topLevelTasks.filter((task) => task.id === id)
    : topLevelTasks;
  await processTasks(tasksToProcess);

  function processTasks(tasks: TaskWithComments[]) {
    return pMap(
      tasks,
      async (task) => {
        index++;
        console.log(
          `Processing ${index}/${allTasks.length}`,
          task.customId,
          task.title
        );
        await createIssueWithComments(task, dryRun);

        const subTasks = allTasks.filter((t) => t.parentId === task.id);
        await processTasks(subTasks);
      },
      { concurrency: 1 }
    );
  }
}

async function createIssueWithComments(
  task: TaskWithComments,
  dryRun: boolean
) {
  try {
    const issue = convertClickUpTaskToLinearIssue(task);
    if (dryRun) {
      issueIdsByTaskId.set(task.id, "<random-id>"); // in the dryMode, we don't have the real ID generated by Linear
      return issue;
    }
    const result = await linearClient.createIssue(issue);

    const issueId = (await result.issue)?.id;
    if (!issueId)
      throw new Error(`No ID returned when creating issue ${task.customId}`);

    issueIdsByTaskId.set(task.id, issueId);

    for (const comment of task.comments) {
      await linearClient.createComment({
        issueId,
        body: `Comment by ${comment.email || "N/A"} \n` + comment.text,
        createdAt: comment.createdAt,
      });
    }

    // Comments have to be added before the issue is archived!
    if (shouldBeArchived(task)) {
      await safeArchiveIssue(issueId);
    }
    return true;
  } catch (error) {
    console.error(`Error migrating ${task.customId} ${task.id}`, error);
    return false;
  }
}

function convertClickUpTaskToLinearIssue(
  task: TaskWithComments
): IssueCreateInput {
  if (!CURRENT_SPRINT_NUMBER) {
    throw new Error("CURRENT_SPRINT_NUMBER is not set");
  }

  const TEAM_ID = process.env.TEAM_ID;
  const PROJECT_ID = process.env.PROJECT_ID;

  if (!TEAM_ID) throw new Error("TEAM_ID is not set");
  if (!PROJECT_ID) throw new Error("PROJECT_ID is not set");

  const assignee = getUserByEmail(task.assignees[0]);
  const isCurrentSprint = task.listName === CURRENT_SPRINT_NUMBER.toString();
  const cycleId = isCurrentSprint
    ? getCycleByName(`Sprint ${CURRENT_SPRINT_NUMBER}`)?.id
    : undefined;

  // const includesPrefix = false;
  // !task.listName.toLowerCase().startsWith("backlog") && !isCurrentSprint;
  // const prefix = includesPrefix ? getSprintName(task.listName!) + " " : "";
  const title = `${task.title}`;

  if (task.parentId && !issueIdsByTaskId.has(task.parentId)) {
    throw new Error(`Parent issue ID not found ${task.parentId}`);
  }
  const parentId = task.parentId
    ? issueIdsByTaskId.get(task.parentId)
    : undefined;

  const labelIds = task.labels
    .map((label) => getLabelByName(label)?.id)
    .filter(Boolean) as string[];

  const issueToCreate: IssueCreateInput = {
    teamId: TEAM_ID,
    projectId: PROJECT_ID,
    title,
    description:
      `Created by ${task.createdBy}: ${task.url}\n` + task.description,
    ...(assignee && { assigneeId: assignee.id }),
    stateId: getStatus(task)!.id,
    ...(task.dueDate && { dueDate: formatDate(task.dueDate) }),
    estimate: task.estimate,
    priority: getPriority(task.priority),
    subscriberIds: task.reviewers
      .map(getUserByEmail)
      .map((user) => user?.id)
      .filter(Boolean) as string[],
    labelIds: labelIds.length ? [labelIds[0]] : undefined, // only add the first label to avoid errors ""
    createdAt: task.createdAt,
    ...(parentId && { parentId }),
    cycleId, // we cannot create cycles in the past
  };
  // console.log("To create", issueToCreate);

  return issueToCreate;
}

/** Attempt to archive, wrapped in a try/catch because of some random errors from the API */
async function safeArchiveIssue(issueId: string) {
  // try {
  //   return await linearClient.archiveIssue(issueId);
  // } catch (error) {
  //   console.error(`Error archiving issue ${issueId}`, error);
  // }

  for (let attempt = 1; attempt <= 10; attempt++) {
    try {
      await linearClient.archiveIssue(issueId);
      return; // success
    } catch (err: any) {
      const isDeadlock =
        err?.response?.errors?.some(
          (e: any) => e.message === "deadlock detected"
        ) ?? false;

      if (!isDeadlock || attempt === 10) throw err;

      const wait = 500 * attempt; // back-off (0.5 s, 1 s, 1.5 sâ€¦)
      await new Promise((r) => setTimeout(r, wait));
    }
  }
}

function shouldBeArchived(task: TaskWithComments) {
  if (!CURRENT_SPRINT_NUMBER) {
    throw new Error("CURRENT_SPRINT_NUMBER is not set");
  }

  if (task.listName === CURRENT_SPRINT_NUMBER.toString()) return false;
  if (task.status === "done" || task.status === "rejected") return true;
  if (task.listName === "backlog") return false;
  if (task.isArchived) return true;
  return false;
}

function getSprintName(listName: string) {
  if (listName.toLowerCase().startsWith("backlog")) return "Backlog";
  return `Sprint ${listName}`;
}

function getStatus(task: TaskWithComments) {
  const { listName, status } = task;
  const notArchivedStatus: TaskWithComments["status"][] = [
    "to do",
    "in progress",
    "parked",
  ];
  if (listName === "backlog" && notArchivedStatus.includes(status)) {
    return getStateByName("Backlog");
  }

  switch (status) {
    case "done":
      return getStateByName("Done");
    case "to do":
      return getStateByName("ToDo");
    case "new":
      return getStateByName("New");
    case "blocked":
      return getStateByName("Blocked");
    case "parked":
      return getStateByName("Parked");
    case "in review":
      return getStateByName("In Review");
    case "won't do":
      return getStateByName("Won't do");
    case "rejected":
      return getStateByName("Canceled");
    case "in progress":
      return getStateByName("In Progress");
    default:
      throw new Error(`Unknown status: ${status}`);
  }
}

function getPriority(input: TaskWithComments["priority"]) {
  return typeof input === "number" ? input + 1 : undefined; // "Urgent" is 1 in Linear, 0 in ClickUp
}

function formatDate(date?: Date) {
  return date ? format(date, "yyyy-MM-dd") : undefined;
}

function showSummary(tasks: TaskWithComments[]) {
  const statuses = countBy(tasks, (task) => task.status);
  const priorities = countBy(
    tasks,
    (task) => "Priority " + (task.priority ?? "not set")
  );
  const estimates = countBy(tasks, (task) => task.estimate ?? "not set");
  const labels = countBy(tasks, (task) => task.labels[0] || "not set");
  const commentsCounts = countBy(
    tasks,
    (task) => `${task.comments.length} comments`
  );
  const reviewers = countBy(tasks, (task) => task.reviewers[0] || "not set");
  console.log(
    statuses,
    priorities,
    estimates,
    labels,
    commentsCounts,
    reviewers
  );
}
